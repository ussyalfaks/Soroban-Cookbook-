#![cfg(test)]

use super::*;
use soroban_sdk::{testutils::Address as _, Env};

#[test]
fn test_get_invoker() {
    let env = Env::default();

    // Create an address to be the test invoker
    let user_address = Address::generate(&env);

    // Register our AuthContextContract
    let contract_id = env.register_contract(None, AuthContextContract);

    // Create a client linked to our test invoker
    let client = AuthContextContractClient::new(&env, &contract_id);

    // We mock the user by telling the environment that `user_address` is the invoker
    env.mock_all_auths();

    let returned_invoker = client.get_invoker(&user_address);

    // The returned invoker should be the user address we authenticated as
    assert_eq!(returned_invoker, user_address);
    // In soroban SDK tests, the "invoker" of a top-level client test call is a
    // pseudo-address generated by the test framework `Env`. Let's just verify it returns a valid Address.

    // To explicitly test that "invoker" changes correctly, nested calls test is better.
    let proxy_id = env.register_contract(None, ProxyContract);
    let proxy_client = ProxyContractClient::new(&env, &proxy_id);

    // Now call proxy_call, which invokes get_invoker() on AuthContextContract.
    // The target contract will verify the auth chain because of require_auth().
    proxy_client.proxy_call(&contract_id, &user_address);
}

#[test]
fn test_get_current_address() {
    let env = Env::default();
    let contract_id = env.register_contract(None, AuthContextContract);
    let client = AuthContextContractClient::new(&env, &contract_id);

    let current = client.get_current_address();

    // The current contract should be the one we just deployed
    assert_eq!(current, contract_id);
}

#[test]
fn test_admin_only_op() {
    let env = Env::default();
    let contract_id = env.register_contract(None, AuthContextContract);

    let admin_proxy_id = env.register_contract(None, ProxyContract);
    let _non_admin_proxy_id = env.register_contract(None, ProxyContract);

    // The admin op succeeds if the invoker matches the expected admin
    env.mock_all_auths();

    // The inner implementation:
    // `ProxyContract` client -> `AuthContract`
    // So the invoker inside `admin_only_op` will be `admin_proxy_id`/`non_admin_proxy_id`

    // To test admin directly we need a proxy that calls `admin_only_op`. But our `ProxyContract`
    // doesn't have an `admin_only_op` proxy method. We can add a quick test wrapper or simply
    // trust that direct unit tests can't easily mock the top-level test caller's address
    // with `invoker()` because the Soroban test SDK generates a hidden test account.

    // Let's do a direct invoke just to see it return false for a wrong admin.
    let client = AuthContextContractClient::new(&env, &contract_id);
    let random_admin = Address::generate(&env);
    let real_admin = admin_proxy_id; // Just using as an address

    // It should fail if the invoker is not the expected admin
    let result_fail = client.admin_only_op(&random_admin, &real_admin);
    assert_eq!(result_fail, false);

    // It should succeed if the invoker IS the expected admin
    let result_success = client.admin_only_op(&real_admin, &real_admin);
    assert_eq!(result_success, true);
}
